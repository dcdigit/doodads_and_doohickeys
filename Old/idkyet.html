<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StencilForge // Generative Cut File Tool</title>
    <style>
        :root {
            --bg: #1a1a1a;
            --panel: #252525;
            --accent: #ff4d4d; /* Industrial Orange/Red */
            --text: #f0f0f0;
        }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Courier New', monospace; color: var(--text); }
        
        #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* HUD UI */
        .hud-panel {
            position: absolute;
            z-index: 10;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            padding: 15px;
            border: 1px solid #444;
            border-radius: 4px;
        }
        
        #status-bar {
            bottom: 20px; left: 20px;
            font-size: 12px;
            color: #888;
            display: flex;
            gap: 20px;
        }
        .status-item span { color: var(--accent); font-weight: bold; }

        /* Custom GUI Tweaks */
        .lil-gui { 
            --background-color: var(--panel);
            --text-color: var(--text);
            --title-background-color: var(--accent);
            --widget-color: #444;
            --hover-color: #555;
            --focus-color: #777;
            --number-color: var(--accent);
        }
    </style>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="status-bar" class="hud-panel">
        <div class="status-item">MODE: <span>BINARY CUT</span></div>
        <div class="status-item">RES: <span>HIGH</span></div>
        <div class="status-item">BRIDGES: <span>ACTIVE</span></div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- CONFIG ---
        const config = {
            // Viewport
            width: window.innerWidth,
            height: window.innerHeight,
            
            // Colors (High Contrast for Stencils)
            colorCut: '#ffffff', // The hole
            colorSolid: '#000000', // The material
            
            // Grid / Layout
            gridX: 12,
            gridY: 12,
            polarMode: false, // WARP to Circle
            
            // Geometry
            shapeType: 1, // 0:Circle, 1:Square, 2:Hex, 3:Cross
            strokeWidth: 0.15, // Thickness of the cut line
            filled: false,     // Solid shape vs Outline
            
            // Bridges (The Stencil Logic)
            bridgeSize: 0.1,  // Size of gaps
            bridgeCount: 2,   // How many bridges per shape
            bridgeRotate: 0.0,
            
            // Warp / Imperfection (Organic Look)
            noiseScale: 1.5,
            warpStrength: 0.0,
            
            // Transform
            rotation: 0.0,
            scaleNoise: 0.0, // Variance in size
            
            saveImage: () => saveCanvas()
        };

        const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            uniform float uAspect;
            uniform vec2 uGrid;
            uniform vec3 uColorCut;
            uniform vec3 uColorSolid;
            
            uniform bool uPolar;
            uniform int uShapeType;
            uniform float uStrokeWidth;
            uniform bool uFilled;
            
            uniform float uBridgeSize;
            uniform float uBridgeCount;
            uniform float uBridgeRotate;
            
            uniform float uWarp;
            uniform float uNoiseScale;
            uniform float uRotation;
            uniform float uScaleNoise;

            varying vec2 vUv;

            // --- NOISE FUNCS ---
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
            float snoise(vec2 v) {
                const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
                vec2 i  = floor(v + dot(v, C.yy) );
                vec2 x0 = v - i + dot(i, C.xx);
                vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                vec4 x12 = x0.xyxy + C.xxzz;
                x12.xy -= i1;
                i = mod289(i);
                vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));
                vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
                m = m*m ; m = m*m ;
                vec3 x = 2.0 * fract(p * C.www) - 1.0;
                vec3 h = abs(x) - 0.5;
                vec3 ox = floor(x + 0.5);
                vec3 a0 = x - ox;
                m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
                vec3 g;
                g.x  = a0.x  * x0.x  + h.x  * x0.y;
                g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                return 130.0 * dot(m, g);
            }

            // --- SDF SHAPES ---
            float sdCircle(vec2 p, float r) { return length(p) - r; }
            float sdBox(vec2 p, vec2 b) {
                vec2 d = abs(p) - b;
                return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
            }
            float sdHex(vec2 p, float r) {
                const vec3 k = vec3(-0.866025404, 0.5, 0.577350269);
                p = abs(p);
                p -= 2.0*min(dot(k.xy, p), 0.0)*k.xy;
                p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);
                return length(p)*sign(p.y);
            }
            // A simple cross
            float sdCross(vec2 p, float s, float w) {
                vec2 b = vec2(s, w);
                vec2 d1 = abs(p) - b;
                vec2 d2 = abs(p) - b.yx;
                float dist1 = length(max(d1, 0.0)) + min(max(d1.x, d1.y), 0.0);
                float dist2 = length(max(d2, 0.0)) + min(max(d2.x, d2.y), 0.0);
                return min(dist1, dist2);
            }

            // Rotate function
            vec2 rotate(vec2 v, float a) {
                float s = sin(a); float c = cos(a);
                mat2 m = mat2(c, -s, s, c);
                return m * v;
            }

            void main() {
                vec2 st = vUv;
                
                // 1. Polar Transform (Ceramic Mode)
                if (uPolar) {
                    vec2 centered = st - 0.5;
                    // Cartesian to Polar
                    float angle = atan(centered.y, centered.x);
                    float radius = length(centered) * 2.0; // Zoom out slightly
                    
                    // Map back to 0-1 for grid logic
                    // x becomes Angle, y becomes Radius
                    st = vec2(angle / 6.2831 + 0.5, radius);
                }

                // 2. Global Warp (Organic Disturbance)
                if (uWarp > 0.0) {
                    float n = snoise(st * uNoiseScale);
                    st += n * uWarp * 0.1;
                }

                // 3. Grid Logic
                vec2 gridSt = st * uGrid;
                vec2 cellId = floor(gridSt);
                vec2 cellUv = fract(gridSt) - 0.5;
                
                // 4. Per-Cell Variation
                float rnd = snoise(cellId * 10.0); // Random float -1 to 1
                
                // Scale jitter
                float currentScale = 0.4 + (rnd * uScaleNoise * 0.2);
                
                // Rotation
                float currentRot = uRotation;
                if (uScaleNoise > 0.0) currentRot += rnd * 3.14; // Random rot if noise is high

                // Apply Rotation to UV
                cellUv = rotate(cellUv, currentRot);

                // 5. Shape SDF
                float d = 0.0;
                if (uShapeType == 0) d = sdCircle(cellUv, currentScale);
                else if (uShapeType == 1) d = sdBox(cellUv, vec2(currentScale));
                else if (uShapeType == 2) d = sdHex(cellUv, currentScale);
                else if (uShapeType == 3) d = sdCross(cellUv, currentScale, currentScale * 0.3);

                // 6. Stroke / Fill Logic
                float shapeMask = 0.0;
                
                if (uFilled) {
                    // Solid Shape: Inside is white
                    shapeMask = 1.0 - step(0.0, d);
                } else {
                    // Outline: Absolute distance < thickness
                    // We use step() for hard edges (no anti-aliasing gradient)
                    float thickness = uStrokeWidth * 0.5;
                    shapeMask = 1.0 - step(thickness, abs(d));
                }

                // 7. BRIDGE GENERATOR (The Stencil Feature)
                // Cuts gaps in the shape based on angle
                if (uBridgeSize > 0.0) {
                    // Calculate angle of current pixel relative to cell center
                    float angle = atan(cellUv.y, cellUv.x) + uBridgeRotate;
                    
                    // Normalize angle to 0-1 range over PI*2
                    float normAngle = (angle / 6.2831) + 0.5;
                    
                    // Repeat the gap uBridgeCount times
                    float bridgePattern = fract(normAngle * uBridgeCount);
                    
                    // If we are inside the "gap" zone, cut the mask
                    // We step based on bridgeSize
                    float gap = step(uBridgeSize, bridgePattern); // 0 if inside gap, 1 if material
                    
                    shapeMask *= gap;
                }
                
                // 8. Polar Cleanup (Hide center singularity artifact)
                if (uPolar && st.y < 0.05) shapeMask = 0.0;

                // 9. Color Output
                vec3 finalColor = mix(uColorSolid, uColorCut, shapeMask);
                
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        // --- SETUP ---
        const container = document.getElementById('canvas-container');
        const renderer = new THREE.WebGLRenderer({ antialias: false, preserveDrawingBuffer: true }); // False AA for sharp pixels
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(config.width, config.height);
        container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
        camera.position.z = 1;

        const material = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader,
            uniforms: {
                uAspect: { value: config.width / config.height },
                uGrid: { value: new THREE.Vector2(config.gridX, config.gridY) },
                uColorCut: { value: new THREE.Color(config.colorCut) },
                uColorSolid: { value: new THREE.Color(config.colorSolid) },
                uPolar: { value: config.polarMode },
                uShapeType: { value: config.shapeType },
                uStrokeWidth: { value: config.strokeWidth },
                uFilled: { value: config.filled },
                uBridgeSize: { value: config.bridgeSize },
                uBridgeCount: { value: config.bridgeCount },
                uBridgeRotate: { value: config.bridgeRotate },
                uWarp: { value: config.warpStrength },
                uNoiseScale: { value: config.noiseScale },
                uRotation: { value: config.rotation },
                uScaleNoise: { value: config.scaleNoise }
            }
        });

        const quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
        scene.add(quad);

        // --- UTILS ---
        function updateUniforms() {
            const u = material.uniforms;
            u.uGrid.value.set(config.gridX, config.gridY);
            u.uColorCut.value.set(config.colorCut);
            u.uColorSolid.value.set(config.colorSolid);
            u.uPolar.value = config.polarMode;
            u.uShapeType.value = config.shapeType;
            u.uStrokeWidth.value = config.strokeWidth;
            u.uFilled.value = config.filled;
            u.uBridgeSize.value = config.bridgeSize;
            u.uBridgeCount.value = config.bridgeCount;
            u.uBridgeRotate.value = config.bridgeRotate;
            u.uWarp.value = config.warpStrength;
            u.uNoiseScale.value = config.noiseScale;
            u.uRotation.value = config.rotation;
            u.uScaleNoise.value = config.scaleNoise;
            u.uAspect.value = config.width / config.height;
        }

        function saveCanvas() {
            renderer.render(scene, camera);
            const link = document.createElement('a');
            link.download = `stencil-${Date.now()}.png`;
            link.href = renderer.domElement.toDataURL('image/png');
            link.click();
        }

        // --- GUI ---
        const gui = new GUI({ title: 'STENCIL FORGE', width: 300 });

        const fMain = gui.addFolder('1. Layout & Grid');
        fMain.add(config, 'polarMode').name('Polar Warp (Plate)').onChange(updateUniforms);
        fMain.add(config, 'gridX', 1, 50, 1).name('Grid X / Radial').onChange(updateUniforms);
        fMain.add(config, 'gridY', 1, 50, 1).name('Grid Y / Rings').onChange(updateUniforms);
        
        const fShape = gui.addFolder('2. Cut Geometry');
        fShape.add(config, 'shapeType', { Circle: 0, Square: 1, Hex: 2, Cross: 3 }).name('Shape').onChange(updateUniforms);
        fShape.add(config, 'filled').name('Solid Fill').onChange(updateUniforms);
        fShape.add(config, 'strokeWidth', 0.01, 0.5).name('Line Thickness').onChange(updateUniforms);
        fShape.add(config, 'rotation', 0, 3.14).name('Rotation').onChange(updateUniforms);

        const fBridge = gui.addFolder('3. Bridge (Islands)');
        fBridge.add(config, 'bridgeSize', 0.0, 0.5).name('Gap Size').onChange(updateUniforms);
        fBridge.add(config, 'bridgeCount', 1, 8, 1).name('Gap Count').onChange(updateUniforms);
        fBridge.add(config, 'bridgeRotate', 0, 3.14).name('Gap Angle').onChange(updateUniforms);

        const fOrganic = gui.addFolder('4. Organic Noise');
        fOrganic.add(config, 'warpStrength', 0, 1.0).name('Warp Distort').onChange(updateUniforms);
        fOrganic.add(config, 'scaleNoise', 0, 1.0).name('Random Sizes').onChange(updateUniforms);
        fOrganic.add(config, 'noiseScale', 0.1, 5.0).name('Noise Freq').onChange(updateUniforms);

        gui.add(config, 'saveImage').name('EXPORT PNG');

        // Render Loop (Static unless params change, but running loop for simplicity)
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        updateUniforms();
        animate();

        window.addEventListener('resize', () => {
            config.width = window.innerWidth;
            config.height = window.innerHeight;
            renderer.setSize(config.width, config.height);
            updateUniforms();
        });
    </script>
</body>
</html>